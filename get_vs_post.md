### GET和POST到底有什么区别？

​	这个问题看起来很初级，但是实际上却涉及到方方面面，这就是为啥面试你是老特么喜欢这个问题了，能真的说明白的真的比较少。



​	HTTP最早用来做浏览器与服务器之间交互HTML和表单的通讯协议；后来又被广泛的扩充到接口格式的定义上。所以在讨论GET和POST区别时候，需要确定下到底是浏览器使用的GET和POST还是HTTP作为接口传输协议的场景。



#### 浏览器的GET和POST

​	这里特指浏览器中的非AJAX的HTTP请求，即从HTML和浏览器诞生就一直使用的HTTP协议中的GET/POST。浏览器用GET请求来获取一个html页面/图片/css/js等资源；用POST来提交一个<form>表单，并得到一个结果的网页。

​	浏览器将GET和POST请求定义为：

##### GET

​	‘读取’一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。比如‘GET’一下，用户就下单了，返回订单已经受理，这是不可接受的【这谁顶得住啊】

​	**没有副作用被称为‘’幂等‘（idempotent）**

​	因为GET是读取，就可以对get请求的数据做**缓存**，这个缓存可以做到浏览器本身上——**彻底避免浏览器发请求**，也可以做到代理上——**nginx**，或者做到sever端——**Etag，至少可以减少带宽消耗**

~~~Etag
Etag 是URL的Entity Tag，用于标示URL对象是否改变，区分不同语言和Session等等。具体内部含义是使服务器控制的，就像Cookie那样。

HTTP协议规格说明定义ETag为“被请求变量的实体值”。另一种说法是，ETag是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：ETag:"50b1c1d4f775c61:df3"客户端的查询更新格式是这样的：If-None-Match : W / "50b1c1d4f775c61:df3"如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。测试Etag主要在断点下载时比较有用
~~~





##### POST

​	在页面里<form>标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做点事。这件事往往是有**副作用**的。

​	**有副作用是不’幂等‘**

​	**不幂等也就意味着不能随意多次执行。因此也就不能缓存**。因为post可能有副作用，所以浏览器实现为不能把POST请求保存为标签——点一下标签就下一个单，这谁顶得住啊？

​	此外，如果尝试重新执行POST请求，浏览器也会弹一个框提示这个刷新可能会有副作用，询问要不要继续。



​	当然了，服务器的开发者完全可以把GET实现为有副作用；把POST实现为没有副作用。只不过和浏览器的预期不符。**把GET请求实现为有副作用是个很可怕的事情**。之前百度贴吧有一个因为使用get请求可以修改管理员权限而造成的安全漏洞。反过来，把没有副作用的请求用POST实现，浏览器还是会弹框，对用户体验好处改善不大。

​	

​	但是后边可以看到，**将HTTP POST作为接口形式使用时，就没有这种弹框了。于是把一个POST请求实现为幂等就有实际意义了**。**POST幂等能让很多业务的前后端交互更加顺畅，以及避免一些因为前端的BUG，触控失误等带来的重复提交**。将一个有副作用的操作实现为幂等**必须从业务上能定义出怎么就算是’重复‘**。如果提交数据中增加一个dedupkey在一个交易会话中有效，或者利用提交的数据里可以天然当dedupkey的字段。这样万一用户强行重复提交，服务器端也可以做一次防护。

​	**ps：dedupkey：使用一个由客户端生成的，可用于避免重复的key**，俗称**dedup key**（deduplicate key之意），这个key可以用任意可以保证全局唯一性的方式生成，比如uuid。客户端和服务器需要使用这个dedup key作为串联条件，一起解决去重问题。

​	

​	GET和POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器地址栏输入，要么就是点击了html里的a标签的href中的url。所以其实并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以没得办法，get上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。



​	浏览器的POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有两种格式，**一种是application/x-www-form-urlencoded**用来传输简单的数据，大概就是’key1=value1&key2=value2‘这样的格式。**另外一种是传文件，会采用multipart/form-data格式**。**采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效**



​	浏览器在POST一个表单时，url上也可以携带参数，只要<form action='url'>里的url带querystring就行。只不过表单里的那些用<input>等标签经过用户操作产生的数据都会在body里



​	因此我们一般会**泛泛的说’GET请求没有body只有url，请求数据放在querystring中；POST请求的数据在body中’**，但是！！！**这种情况仅仅限于浏览器发请求的场景！**



### 接口中的GET和POST

​	 这里是指的是通过浏览器的Ajax api，或者IOS/Android的App的http client， java的commands-httpclient/okhttp或者是curl， postman这几类的工具发出来的GET和POST请求。其实GET/POST不光能用在前端和后端的交互中，还能用在后端的各个自服务的调用中（即当一种RPC【远程过程调用】协议使用），尽管RPC有很多协议，比如thrift，grpc，但是http本身已经有大量的现成的支持工具可以使用，并且都对人类很友好，很容易debug。HTTP协议在微服务的使用是非常普遍的。



​	当用HTTP实现接口发送请求时，就没有浏览器中那么多限制了，只要是符合HTTP格式的就可以发。HTTP请求的格式，大概是这样的一个字符串【\r\n换行了】：

~~~html
<METHOD><URL> HTTP/1.1\r\n
<Header1>:<HeaderValue1>\r\n
<Header2>:<HeaderValue2>\r\n
    ...
<HeaderN>:<HeaderValueN>\r\n
    \r\n
<Body Data...>
~~~

​	其中的<METHOD>可以是GET也可以是POST，或者是其他的HTTP Method。比如PUT,DELETE,OPTION...。从协议本身看，并没有什么限制说GET一定不能没有body，POST就一定不能把参数放到<URL>的querystring上。因此其实可以更加自由的去利用个格式。比如Elastic Search的_search api就是用了带body的GET；也可以自己开发接口让POST一半的参数放在url的querystring里，另一半放在body里；你甚至还可以让所有的参数都放在Header里——可以做各种各样的限制，只要请求的客户端和服务器能够约定好。

~~~ps
 注：ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口
~~~



​	**当然太自由也带来了另一种麻烦**，开发人员不得不每次讨论确定参数是放url的path里，querystring里，body里，header里这种问题，太低效了。于是就有了一系列接口规范/风格。其中名气最大的当数REST。REST充分运用GET,POST,PUT和DELETE，约定了这4个接口分别获取，创建，替换和删除资源，**REST最佳实践还推荐在请求体使用json格式。**这样仅仅通过http的method就可以明白接口是什么意思，并且解析格式也得到了统一。

~~~markdown
json相对于x-www-form-urlencode的优势在于：
	1. 可以有嵌套结构；
	2.可以支更丰富的数据类型，通过一些框架，json可以直接被服务器代码映射为业务实体。用起来十分方便。但是如果是写一个接口支持上传文件，那么还是multipart/form-data格式更合适
~~~

​	REST中的GET和POST不是随便用的。在REST中，**GET + 资源定位符 被专用于获取资源或者资源列表**

比如：

~~~html
GET http://foo.com/books  --获取书籍列表--
GET http://foo.com/books/:bookId  --根据bookId获取一本具体的书--
~~~

​	与浏览器的场景相似，REST GET也不应有副作用，于是可以被反复无脑调用。浏览器（包括浏览器的Ajax请求）对于这种GET也可以实现缓存（如果服务器端提示了明确要Caching）；**但是如果用非浏览器**，有没有缓存完全看客户端的实现了。当然也可以从整个App角度，也可以完全绕开浏览器的缓存机制，实现一套业务定制的缓存框架（**可学习okhttp中控制Cache的类**）

​	

​	REST中的POST则用于创建资源  【POST】 + **资源定位符**

比如：

~~~html
POST http://foo.com/books
{
	"title:"you see you one day day",
	"author":"wsh",
	.....
}
~~~

​	这里就能留意到**浏览器中用来实现表单提交的POST，和REST里实现创建资源的POST语义上的不同**

~~~markdown
提下REST POST和REST PUT的区别。有些api是使用PUT作为创建资源的Method。PUT和POST的去别人在于，PUT的实际语义是“replace”replace。REST规范里提到的PUT请求应该是完整的资源，包括id在内。比如上面的创建一本书的api也可以定义为：
PUT http://foo.com/books
{
	"id":"BOOK:AFFE001BB0556A",
	"title:"you see you one day day",
	"author":"wsh",
	.....
}
服务器应该根据请求提供的id进行查找，如果存在一个对应的id的元素，就用请求中的数据*整体替换*已经存在的资源；如果没有，就用”把这个id对应的资源从【空】替换为请求数据“。——直观的看起来就是”创建“了。

	与PUT相比，POST更像一个”factory“，通过一组必要的数据创建出完整的资源。
	至于到底是用PUT还是POST创建资源，完全要看是不是提前可以知道资源所有的数据（尤其是id），以及是不是完整替换。
		比如对于AWS S3这样的对象存储服务，当想上传一个新资源时，其id就是”ObjectName“可以提前知道。这个api也总是完整的replace整个资源。这时的api用PUT的语义更合适；而对于那些id是服务器端自动生成的场景，POST更合适一些。
		
跑题了 打住
~~~



回到接口这个主题，上面仅仅粗略的介绍了REST的情况，但是现实中总是有REST的变体，也可能使用非REST的协议：比如JSON-RPC,SOAP等，每种情况的GET和POST又会有所不同。





### 关于安全性

​	我们常常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是，**从攻击角度**，无论时GET还是POST都不够安全，因为HTTP本身就是**明文协议**。每个HTTP请求和返回的每个byte都会在网络上传播，不管是url，header还是body。**这完全不是一个‘是否在浏览器地址栏上看到’的问题**



​	为了避免传输中数据被窃取，**必须做从客户端到服务端的端端加密。业界通行的做法就时HTTPS——即用SSL协议协商出的密钥加密明文的http数据。**这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/APP，要保证安全，https是最基本的要求。

~~~https
当然，端端加密并不一定非得用https。比如国内金融领域都会用私有网络，也有GB得加密协议SM系列。但是除了军队，金融等特殊机构之外，似乎没有必要自己发明一套类似于SSL的协议
~~~



​	回到HTTP本身，的确GET请求的参数更倾向于放在url上，因此会有更多的机会被泄露。比如携带私密信息的url会展示在地址栏上，还可以分享给第三方，就非常不安全了。此外，**从客户端都服务器端，有大量的中间节点，包括网关，代理等**。他们的access log通常会输出完整的url，比如**nginx的默认access log就是如此**。如果url携带敏感数据，就会被记录下来。**但是请注意，就算私密数据在body里，也是可以被记录下来的，因此如果请求要经过不信任的公网，避免泄密的唯一手段就是https**。这里说的“避免access log泄露”仅仅是***指避免可信区域中的http代理的默认行为带来的安全隐患。**比如你是不太希望让自己公司的运维同学从公司主网关的log里看到用户的密码吧

![](.\img\HTTPS.png)



​	另外，上面也讲过，如果是作为接口，GET实际上也可以带body,POST也可以在url上携带数据。所以实际上到底怎么传输私密数据，要看具体场景具体分析。当然，绝大多数场景，POST+body里写私密数据是合理的选择。一个典型的例子就是“登录”。

​	安全是一个巨大的主题，又有很多的细节组成一个完备体系，比如返回私密数据的mask，XSS，CSFR，跨域安全，前端加密，钓鱼，salt，... POST和GET在这件事上只是一个小角色，因此单独讨论POST和GET本身哪个更安全意义并不是太大。**只要记住一般情况下，私密数据传输用POST+body就好**。



### 关于编码

​	常见的说法有，比如GET的参数只支持ASCII，而POST能支持任意binary，包括中文。单其实上面可以看到，GET和POST实际上都能用url和body。**因此所为的编码确切的说是http中url用什么编码，body用什么编码**。



​	先说下url。url只能支持ASCII的说法源自于RFC1738【 *RFC1738*描述的是统一资源定位器(URL)】

~~~RFC1738
thus， onlyalphanumerics，the specialcharacters "$-_.+!'()," ,and reserved characters used for their reserved purposes may be used unencoded whth in a URL.
~~~

​	**实际上这里规定的仅仅是一个ASCII的子集[a-zA-Z0-9$-_+!*'(),]。它们是可以“不经编码”在url中使用。比如尽管空格也是ASCII字符，但是不能直接在url里。**

​	

​	那这个编码是什么呢？如果有了特殊符号和中文怎么办呢？这里要介绍一种叫做percent-enconding的方法

[https://en.wikipedia.org](https://en.wikipedia.org/)

​	这也就是为啥我们偶尔看到url里有一坨%和16位数字组成的序列

​	

​	使用percent encoding ， 即使是binary data，也是可以通过编码后放在URL上的

​	**但是要特别注意，这个编码方式只管把字符转换成URL可用字符，但是却不管字符集编码**，比如中文到底是用UTF8还是GBK，这块早期就相当乱，也没有什么统一的规范。比如有时跟网页编码一样，有的是操作系统的编码一样，最要命的是浏览器的地址栏是不受开发者控制的这样，对于同样一个带中文的url，如果有的浏览器一定要用GBK【比如老的IE8】，有的一定要用UTF8【比如chrome】。后端可能就认不出来。对此常用的办法是避免让用户输入带中文的url。**如果有这种形式的请求，都改成用户界面上输入，然后通过ajax发出的办法。ajax发出的编码形式开发者是可以100%控制的**

~~~markdown
不过目前基本上utf8已经大致统一了。现在的开发者除非是被国家规定要求一定要用GBk系列编码的场景，基本不会再遇到这类问题了
~~~

​	关于url的编码，阮一峰的一片文章有比较详细的解释

<http://www.ruanyifeng.com/blog/2010/02/url_encoding.html>

~~~markdown
顺便说一句，尽管在浏览器地址栏可以看到中文，但是这种url在发送请求的过程中，浏览器会把中文用字符编码+Percent-encoding翻译为真正的url，再发给服务器。浏览器地址栏里的中文这必是想让用户体验更好些而已
~~~



​	再讨论下body。HTTP Body相对好些，因为有个Content-Type来比较明确的定义。

比如：

~~~body
POST XXXXXXX HTTP/1.1
..
Content-Type: application/x-www-form-urlencode; charset=utf-8
~~~

​	这里的Content-Type会同时定义**请求body的格式【application/x-www-form-urlencode】**和**字符编码【charset】**

​	所以body和url都可以提交中文数据给后端，但是**POST规范好一些，相对不容易出错**，容易让开发者安心。对于GET+url的情况，只要不涉及到再老旧浏览器的地址栏输入url，也不会有什么太大的问题。



​	回到POST，浏览器直接发出的POST请求就是表单提交，而表单提交只有application/x-www-form-urlencode针对简单的key-value场景，和multipart/form-data，针对只有文件提交，或者同时又文件和key-value的混合提交表单的场景

​	如果是ajax或者其他http client发出去的POST请求，其body格式就非常自由了，常用的有json，xml，文本，csv。。。甚至是你自己发明的格式。只要前后端能约定好就行了。





### 浏览器的POST需要发两个请求吗？

​	上文中的‘HTTP’格式清楚的显示了HTTP请求可以被大致分为‘请求头’和‘请求体’两个部分。使用HTTP请求时大家会有一个约定，即**所有的“控制类”信息应该放在请求头中，具体的数据应该放在请求体里**。于是服务器端解析时，总是会先完全解析全部的请求头部。这样，**服务器端总是希望能够了解请求的控制信息后，就能决定这个请求怎么进一步处理，是拒绝还是根据content-type去调用相应的解析器处理数据， 或者直接用zero copy转发**

​		

~~~zero copy
ps： zero copy   零拷贝
zero copy技术就是减少不必要的内核缓冲区跟用户缓冲区间的拷贝，从而减少CPU的开销和内核态切换开销，达到性能的提升。
zero copy下，同样的读取文件然后通过网络发送出去，只需要拷贝三次，只发生两次内核态和用户态的切换。
~~~

~~~linux zero copy
linux下的zero copy技术
linux下的用来实现zero copy的常见接口由如下几个：

ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)
long splice(int fdin, int fdout, size_t len, unsigned int flags);
这两个接口都可以用来在两个文件描述符之间传输数据，实现所谓的zero copy。
splice接口则要求两个文件描述符中至少要有一个是pipe。

sendfile跟splice的局限性
上面提到的用来实现零拷贝的sendfile和splice接口，仅限于文件跟文件，文件跟sock之间传输数据，但是没法直接在两个socket之间传输数据的。这就是sendfile和splice接口的局限性。
如果要实现socket跟socket之间的数据直接拷贝，需要开辟一个pipe，然后调用两次splice。这样还是带来跟传统IO读写一样的问题。系能其实并没有什么大的提升。
~~~



​	比如在用java写服务时，请求处理代码总是能从HttpServerRequest里getParameter/Header/url。这些信息都是请求头里的，框架之就解析了，而对于**请求体，只提供了一个inputstream，如果开发人员觉得应该进一步处理，就自己去读取和解析请求体**，这就能体现出服务器端对请求头和请求体的不同处理方式

​	

​	举个例子，比如写一个上传文件的请求，请求url中包含了文件名称，请求体中是个尺寸为几百兆的压缩二进制流。服务器端接收到请求后，就可以先拿到请求头部，查看用户是不是有权限上传，文件名是不是符合规范等。如果不符合，就不再处理请求体的数据了，直接丢弃。而不用等到整个请求都处理完了再拒绝。



​	为了进一步优化，**客户端可以利用HTTP的Continued协议来这样做： 客户端总是先发送所有的请求头给服务器，让服务器校验。如果通过了，服务器回复 “100 - Continue”， 客户端再把剩下的数据发给服务器， 如果请求被拒绝了，服务器就回复个400之类的错误，这个交互就中止了。这样，就可以避免浪费带宽传请求体。但是代价就是会多一次Round Trip。 如果刚好请求提的数据也不多，那么一次性全部发给服务器可能反而更好**

​	基于此，客户端就能做一些优化，比如内部设定一次POST数据超过1KB就执行“请求头”，否则就一次性全发。**客户端甚至还可以做一些Adaptive的策略，统计发送成功率，如果成功率很高，就总是全部发送等等**。不同浏览器，不同客户端（curl， postman）可以有各自的不同方案。不管怎么做，**优化目的总是再提高数据吞吐和降低带宽上做一个折衷**

​	

​		因此到底是发一次还是发N次，客户端可以很灵活的决定。因为不管怎么发都是符合HTTP协议的，因此我们应该视为这种优化是一种实现细节，而不用扯到GET和POST本身的区别上。更不要当个什么世纪大发现。



### 到底什么算请求体

​		看完了上面的内容后，读者也许会对“什么是请求体”感到困惑不已，蔽日x-www-form-encode编码的body算不算“请求体”呢？

​		从HTTP协议的角度，**请求头**就是Method+URL（包含querystring）+Headers；再后边的都是请求体。

​		**但是从业务角度，如果你把一次请求立即为一个调用的话**。比如上面：

~~~HTML
POST http：//foo.com/books
{
	“title”：“大宽宽的碎碎念”，
	“author”：“小宽宽”
}

————————》 用某种语言
createBook("大宽宽的碎碎念", "小宽宽")
~~~



​		**那么这一行函数名和两个参数都可以看作是请求，不区分头和体**。即便http协议实现，title和author编码到了http请求体中。java的HTTPserverRequest支持用getParameter方法获取x-www-url-form-encode中的数据，表达的意思就是“请求”的“参数”

​	

​		对于Http， 需要区分【头】和【体】，HTTP Request和HTTP Reonse都这么区分。HTTP这么干主要作用如下：

​		

###### 		· 对于HTTP代理

​				· 支持转发规则，**比如nginx先要解析请求头**，拿到URL和Header才能决定怎么做（转发proxy_pass，重定向redirect，rewrite后重新判断....）

​				· 需要用请求头的信息记录log。尽管请求体里 的数据也可以记录，但一般只记录请求头的部分数据。

​				· 如果代理规则不涉及到请求体，那么请求体就可以不从内核态的page cache复制一份到用户态了，可以直接zero copy转发。这对于上传文件的场景极为有效。

​				· ...

###### 		· 对于HTTP服务器

​				· 可以通过请求头进行ACL【访问控制列表，access control list】控制，比如看看Authorization头里的数据是否能让认证通过

​				· 可以做一些拦截，比如看到Content-Length里的数太大，或者Content-Type自己不支持，或者Accept要求的格式自己无法处理，就直接返回失败了

​				· 如果body的数据很大，利用Stream API，可以方便支持一块一块的处理数据，而不是一次性全部读取出来再操作，以至于占用大量内存

​				· ......

​	

​		但是从高一级的业务角度，我们在意的其实是【请求】和【返回】。当我们说“请求头”这三个字时候，也许实际的意思是【请求】。而用HTTP实现【请求】时，可能仅仅用到【HTTP的请求头】（**比如大部分GET请求**），也可能是【HTTP请求头】+【HTTP请求体】（**比如用POST请求下单**）

​		**总之，这里有两层，不要混**



### 关于URL的长度

​	

​		因为上面提到了不论是GET请求还是POST请求都可以使用URL传递数据，所以我们常说"**GET数据有长度限制**"其实是指的是**URL的长度限制**。



​		http协议本身对URL长度并没有做任何规定。实际显示是客户端/浏览器以及服务端做决定的。



​		先说浏览器。不同浏览器不太一样。比如**我们常说的2048个字符限制，其实是IE8的限制。并且原始文档的说的其实是“url的最大长度是2043个字符， path的部分最长是2048个字符”**，IE8只会的IE URL限制没有查到具体的文档，但是有些资料称IE 11 的地址栏只能输入2047个字符，但是允许用户点击html里的超长URL，这里并没有实验

​			chrome的URL限制是2MB， safari， firefox等浏览器也有自己的限制，大都比IE大的多！

​		

​		然而新的IE已经开始使用Chrome的内核了，也就意味着“浏览器端URL限制长度为2048”这种说法会慢慢称为历史



​		其他客户端例如java的，js的HTTP Client大多数也并没有URL限制最大长度

​		除了浏览器，服务器这边也有限制，**比如apche的LimitRequest指令**。

​	

​		apche实现上限制的是HTTP请求第一行“RequestLine”的长度，即<METHOD><URL><VERSION>那一行。

​		再**比如nginx用large_client_header_buffers指令来分配请求头中的很长数据的buffer**，这个buffer可以用来处理url，header value等

​		

​	tomcat的限制是web.xml里的maxHttpHeaderSize来设置的，控制的是整个“请求头”的总长度。

​	

#### 	为啥要限制？

​		如果写过解析一段字符串的代码就能明白，**解析的时候要分配内存**。对于一个字节流的解析，必须分配buffer来保存所有要存储的数据。而**URL这种东西必须当作一个整体， 无法一块一块处理，于是就处理一个请求时必须分配一整块足够大的内存。如果URL太长，而且并发又很高，就很容易挤爆服务器的内存**，同时，超长的URL的好处并不多，**我也只有处理老系统的url时因为不敢碰原来的逻辑，有的追加更多的数据，才会是使用超长的URL**

​		对于开发者来说，使用超长URL完全是给自己埋坑，需要同时考虑前后端，以及中间代理每一个环节的配置。此外，**超长的URL会影响搜索引擎的爬虫**，有些爬虫甚至无法处理超过2000个字节的URL。**这也就意味着这些URL无法被搜索到，坑爹的玩意儿**

~~~text
注意： 1个汉字字符经过UTF-8编码 + percentencoding后，会变成9个字节，不要算错了
~~~



### 		总结

​		上面讲了一大堆，就是说不要死记硬背GET和POST的区别，而是能从**更广阔的层面去看待和思考这个问题。**

​		最后，协议都是人定的，只要客户端和服务器能彼此认同，就能工作。在常规情况下，用符合规范的方式去实现系统可以减少很多的工作量——大家都约定好了，就不要去折腾了，但是，总有一些情况时得不到满足，常规规范满足不了的，不适合需求的！！！。这个时候请不要思路被规范限制死，更不要死扣RFC。这些规范也许不能处理你遇到的问题：

​		· **Elastic Search的_search接口使用GET，却用body来表达查询，因为查询太复杂，用querystring很麻烦，必须用json格式才舒服，在请求体用json编码更加容易，不用折腾percentencoding**

​		· **用POST写一个接口下单时也要考虑幂等性，因为前端可能实现‘下单按钮’有bug，造成用户一次点击发出N个请求，你不能说因为POST by design应该时不幂等就不管了**



协议是死的，人是活的，遇到实际问题时候灵活运用手上的工具满足需求就好。

